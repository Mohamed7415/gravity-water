<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Interstellar Gargantua - The Nolan Cut</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: move; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #ui {
            position: absolute; top: 20px; left: 30px;
            color: rgba(255, 255, 255, 0.7);
            font-family: "Courier New", monospace;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(255, 140, 0, 0.5);
        }
        h1 { margin: 0; font-size: 20px; letter-spacing: 3px; text-transform: uppercase; color: #fff; }
        .param { font-size: 12px; margin-top: 5px; opacity: 0.8; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>Gargantua</h1>
        <div class="param">RENDERER: RAY MARCHING (REALTIME)</div>
        <div class="param">DOPPLER: OFF (CINEMATIC LOOK)</div>
        <div class="param">COLOR TEMP: 4500K (AMBER)</div>
    </div>
    <canvas id="glcanvas"></canvas>

    <script id="fs" type="x-shader/x-fragment">
        precision highp float;
        uniform vec2 iResolution;
        uniform float iTime;
        uniform vec2 iMouse;

        // --- 电影级参数调优 ---
        #define BH_RADIUS 1.0          // 黑洞视界半径
        #define DISK_INNER 2.6         // 吸积盘内沿 (ISCO)
        #define DISK_OUTER 8.0         // 吸积盘外沿
        #define DISK_HEIGHT 0.12       // 吸积盘厚度 (极薄，带有体积感)
        
        // 诺兰金：电影中的标志性颜色
        const vec3 COLOR_CORE = vec3(1.2, 0.8, 0.5); 
        const vec3 COLOR_EDGE = vec3(1.0, 0.4, 0.1);

        // 噪声函数：用于生成流动的星际尘埃纹理
        float hash(vec3 p) {
            p = fract(p * 0.3183099 + .1);
            p *= 17.0;
            return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
        }

        float noise(vec3 x) {
            vec3 p = floor(x);
            vec3 f = fract(x);
            f = f * f * (3.0 - 2.0 * f);
            return mix(mix(mix(hash(p + vec3(0,0,0)), hash(p + vec3(1,0,0)), f.x),
                           mix(hash(p + vec3(0,1,0)), hash(p + vec3(1,1,0)), f.x), f.y),
                       mix(mix(hash(p + vec3(0,0,1)), hash(p + vec3(1,0,1)), f.x),
                           mix(hash(p + vec3(0,1,1)), hash(p + vec3(1,1,1)), f.x), f.y), f.z);
        }

        // 分形布朗运动 (FBM)：制造细腻的拉丝效果
        float fbm(vec3 p) {
            float f = 0.0;
            float amp = 0.5;
            for(int i=0; i<4; i++) {
                f += amp * noise(p);
                p *= 2.05; 
                amp *= 0.5;
            }
            return f;
        }

        // 旋转矩阵
        mat2 rot(float a) { float s=sin(a), c=cos(a); return mat2(c,-s,s,c); }

        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;

            // 摄像机交互控制
            vec2 m = iMouse.xy / iResolution.xy;
            float camY = (m.x == 0.0) ? 0.0 : (m.x - 0.5) * 6.0;
            float camX = (m.x == 0.0) ? 0.15 : (m.y - 0.5) * 3.0;
            
            vec3 ro = vec3(0.0, 0.0, -12.0); // 摄像机位置
            ro.yz *= rot(camX);
            ro.xz *= rot(camY);
            
            vec3 target = vec3(0.0);
            vec3 fwd = normalize(target - ro);
            vec3 right = normalize(cross(vec3(0,1,0), fwd));
            vec3 up = cross(fwd, right);
            vec3 rd = normalize(fwd * 1.6 + right * uv.x + up * uv.y); // FOV 1.6

            // --- Ray Marching (光线步进) ---
            vec3 col = vec3(0.0);
            vec3 p = ro;
            vec3 dir = rd;
            
            float energy = 0.0; // 累积光能
            float dt = 0.05;    // 步长
            
            for(int i=0; i<200; i++) {
                float r2 = dot(p, p);
                float r = sqrt(r2);
                
                // 1. 引力透镜 (Gravitational Lensing)
                // 模拟光线经过黑洞时的弯曲。
                // 这是一个视觉近似公式，足以产生完美的"爱因斯坦环"。
                if(r > BH_RADIUS) {
                    vec3 accel = -1.5 * p / (r2 * r + 0.05); 
                    dir = normalize(dir + accel * dt * 2.0);
                }
                
                // 2. 移动光子
                p += dir * dt;
                
                // 3. 事件视界 (Event Horizon)
                if(r < BH_RADIUS) {
                    col += vec3(0.0); // 纯黑
                    break;
                }
                
                // 4. 吸积盘渲染 (Volumetric Disk)
                // 检测光线是否进入了吸积盘的体积范围内
                if(abs(p.y) < DISK_HEIGHT && r > DISK_INNER && r < DISK_OUTER) {
                    
                    // 计算纹理坐标 (极坐标)
                    float angle = atan(p.z, p.x);
                    
                    // 动态旋转速度：内圈快，外圈慢 (开普勒第三定律)
                    float speed = 2.5 / sqrt(r); 
                    
                    // 生成云雾纹理
                    vec3 texPos = vec3(r * 2.0, angle * 3.0 + iTime * speed * 0.5, p.y * 8.0);
                    float density = fbm(texPos);
                    
                    // 增加环状细节 (像唱片一样的纹路)
                    density *= (0.6 + 0.4 * sin(r * 30.0));
                    
                    // 边缘淡入淡出
                    float fade = smoothstep(DISK_INNER, DISK_INNER + 0.5, r) * 
                                 smoothstep(DISK_OUTER, DISK_OUTER - 1.0, r);
                    float vFade = smoothstep(DISK_HEIGHT, 0.0, abs(p.y));
                    
                    float alpha = density * fade * vFade * 0.15;
                    
                    // *** 关键：无多普勒效应 ***
                    // 混合核心色与边缘色，保持左右颜色一致
                    vec3 dustColor = mix(COLOR_EDGE, COLOR_CORE, density + 0.3);
                    
                    col += dustColor * alpha * (1.0 - energy);
                    energy += alpha;
                    
                    if(energy > 0.98) break; // 视线被完全阻挡
                }
                
                // 5. 光子层 (Photon Ring)
                // 黑洞边缘那圈极细、极锐利的白线
                float photonDist = abs(r - BH_RADIUS * 1.5);
                if(photonDist < 0.2) {
                     col += vec3(0.8, 0.9, 1.0) * (0.002 / (photonDist * photonDist + 0.005)) * 0.1 * (1.0 - energy);
                }
                
                // 逃逸判定
                if(r > 20.0) break;
            }
            
            // --- 后期合成 (Compositing) ---
            
            // 辉光 (Bloom) - 增加梦幻感
            col += col * 0.6;
            
            // ACES Tone Mapping (电影级色调映射)
            // 将高动态范围的光照压缩进屏幕，防止亮部死白
            float a = 2.51;
            float b = 0.03;
            float c = 2.43;
            float d = 0.59;
            float e = 0.14;
            col = clamp((col * (a * col + b)) / (col * (c * col + d) + e), 0.0, 1.0);
            
            // Gamma 校正
            col = pow(col, vec3(1.0 / 2.2));
            
            // 胶片噪点
            float grain = hash(vec3(uv, iTime)) * 0.03;
            col += grain;

            gl_FragColor = vec4(col, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) { alert("您的浏览器不支持 WebGL"); }

        // 编译着色器
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        const vsSource = `attribute vec2 position; void main() { gl_Position = vec4(position, 0.0, 1.0); }`;
        const fsSource = document.getElementById('fs').text;
        
        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
        gl.linkProgram(program);
        gl.useProgram(program);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 3, -1, -1, 3]), gl.STATIC_DRAW);
        
        const posLoc = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        const uRes = gl.getUniformLocation(program, "iResolution");
        const uTime = gl.getUniformLocation(program, "iTime");
        const uMouse = gl.getUniformLocation(program, "iMouse");

        let mouseX = 0, mouseY = 0;
        
        // 窗口大小自适应
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // 鼠标交互
        document.addEventListener('mousemove', e => {
            if (e.buttons === 1) {
                mouseX = e.clientX;
                mouseY = canvas.height - e.clientY;
            }
        });

        // 渲染循环
        function render(time) {
            gl.uniform2f(uRes, canvas.width, canvas.height);
            gl.uniform1f(uTime, time * 0.001);
            gl.uniform2f(uMouse, mouseX, mouseY);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>