<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gargantua · 电影级黑洞（实时 WebGL）</title>
  <style>
    html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; background: #000; }
    #hud {
      position: fixed; left: 12px; bottom: 12px; color: rgba(255,255,255,.85);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans SC", "Microsoft YaHei", sans-serif;
      font-size: 12px; line-height: 1.35;
      user-select: none; pointer-events: none;
      text-shadow: 0 2px 10px rgba(0,0,0,.8);
      max-width: min(680px, calc(100vw - 24px));
    }
    #hud b { color: #fff; }
    #warn {
      position: fixed; left: 12px; top: 12px; right: 12px;
      padding: 10px 12px; border-radius: 10px;
      background: rgba(255, 60, 60, 0.12);
      border: 1px solid rgba(255, 60, 60, 0.25);
      color: rgba(255,255,255,.92);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans SC", "Microsoft YaHei", sans-serif;
      font-size: 12px; line-height: 1.35;
      display: none;
      z-index: 10;
    }
    #warn code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>

  <!--
    修复点：Three.js 的 examples/jsm 模块内部会用 `import ... from 'three'` 这种“裸模块名”。
    如果没有 importmap，浏览器会报：Failed to resolve module specifier "three"。
    解决：加 importmap，把 "three" / "three/addons/" 映射到 CDN。
  -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="warn"></div>
  <div id="hud">
    <div><b>Gargantua</b> · 近似物理实时渲染（光线弯曲 + 多普勒增亮 + 光子环 + Bloom）</div>
    <div>鼠标拖拽：环绕 | 滚轮：缩放 | 右上角：参数</div>
    <div style="opacity:.82; margin-top:4px;">提示：请用本地 HTTP 服务打开（例如 <code>python -m http.server</code>），不要直接双击 <code>file://</code>。</div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19.2/dist/lil-gui.esm.js';

    // -----------------------------
    // 片元着色器：近似“引力透镜”光线追踪
    // 思路：对每个像素发射一条光线，从相机出发做数值积分，
    //      使用“保持单位方向的弯曲项”来模拟强引力下光线弯曲。
    //      在积分过程中检测是否穿过吸积盘平面并累积辐射；
    //      记录最小半径以构造“光子环”；最终采样背景星空。
    // 注意：这是实时近似，无法 1:1 复刻电影离线 Kerr 几何求解，
    //      但会尽量抓住电影画面的关键视觉特征。
    // -----------------------------

    const warnEl = document.getElementById('warn');
    function warn(msg){
      warnEl.style.display = 'block';
      warnEl.innerHTML = msg;
    }

    // 一点点“自检测试”（没有测试框架时，用断言+错误提示兜底）
    function selfTests({ renderer, gl }){
      console.group('[Gargantua] Self Tests');
      console.assert(!!THREE && typeof THREE.REVISION === 'string', 'THREE 未正确加载');
      console.assert(!!gl, 'WebGL context 获取失败');
      console.assert(typeof renderer.getPixelRatio === 'function', 'renderer 不完整');
      console.log('Three.js REVISION:', THREE.REVISION);
      console.log('WebGL2:', renderer.capabilities.isWebGL2);
      console.groupEnd();
    }

    const VERT = /* glsl */`
      varying vec2 vUv;
      void main(){
        vUv = uv;
        gl_Position = vec4(position.xy, 0.0, 1.0);
      }
    `;

    const FRAG = /* glsl */`
      precision highp float;
      varying vec2 vUv;

      uniform vec2  uRes;
      uniform float uTime;
      uniform vec3  uCamPos;
      uniform mat3  uCamMat;
      uniform float uFov;

      // 黑洞与吸积盘参数
      uniform float uMass;        // 质量（单位化）
      uniform float uSpin;        // 自旋（0..1，近似帧拖曳）
      uniform float uDiskInner;   // 盘内半径
      uniform float uDiskOuter;   // 盘外半径
      uniform float uDiskThick;   // 盘厚度
      uniform float uDiskGlow;    // 盘亮度
      uniform float uDiskTint;    // 盘偏色
      uniform float uBend;        // 弯曲强度（视觉校准）
      uniform float uSteps;       // 积分步数
      uniform float uStepFar;
      uniform float uStepNear;
      uniform float uBg;          // 背景强度
      uniform float uRingBoost;   // 光子环增强
      uniform float uVignette;

      // --------- 工具：hash / noise / fbm ---------
      float hash12(vec2 p){
        vec3 p3 = fract(vec3(p.xyx) * 0.1031);
        p3 += dot(p3, p3.yzx + 33.33);
        return fract((p3.x + p3.y) * p3.z);
      }

      float noise(vec2 p){
        vec2 i = floor(p);
        vec2 f = fract(p);
        float a = hash12(i);
        float b = hash12(i + vec2(1.0, 0.0));
        float c = hash12(i + vec2(0.0, 1.0));
        float d = hash12(i + vec2(1.0, 1.0));
        vec2 u = f*f*(3.0-2.0*f);
        return mix(a, b, u.x) + (c - a)*u.y*(1.0-u.x) + (d - b)*u.x*u.y;
      }

      float fbm(vec2 p){
        float v = 0.0;
        float a = 0.5;
        mat2 m = mat2(1.6, 1.2, -1.2, 1.6);
        for(int i=0;i<5;i++){
          v += a * noise(p);
          p = m * p;
          a *= 0.5;
        }
        return v;
      }

      // --------- 颜色：黑体（近似） ---------
      vec3 blackbody(float t){
        // t: Kelvin
        t = clamp(t, 800.0, 12000.0);
        float x = t / 6500.0;
        // 简化的暖冷插值：
        vec3 warm = vec3(1.0, 0.78, 0.55);
        vec3 mid  = vec3(1.0, 0.96, 0.90);
        vec3 cool = vec3(0.80, 0.90, 1.0);
        vec3 c = mix(warm, mid, smoothstep(0.0, 1.0, x));
        c = mix(c, cool, smoothstep(1.0, 1.8, x));
        // 轻微的“电影偏色”
        c *= vec3(1.0, 0.98, 1.05);
        return c;
      }

      // --------- Tone mapping（ACES 近似） ---------
      vec3 acesFilm(vec3 x){
        float a = 2.51;
        float b = 0.03;
        float c = 2.43;
        float d = 0.59;
        float e = 0.14;
        return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);
      }

      // --------- 背景星空（程序化） ---------
      vec3 sampleBackground(vec3 dir){
        // 球面坐标 -> 2D
        float u = atan(dir.z, dir.x) / (6.28318530718) + 0.5;
        float v = asin(clamp(dir.y, -1.0, 1.0)) / 3.14159265359 + 0.5;
        vec2 p = vec2(u, v);

        // 星云
        float neb = fbm(p*6.0 + vec2(0.0, uTime*0.005));
        vec3 nebCol = mix(vec3(0.02,0.03,0.06), vec3(0.05,0.03,0.07), neb);
        nebCol += 0.06*vec3(0.10,0.06,0.14)*pow(neb, 3.0);

        // 星点（多层阈值）
        float s1 = smoothstep(0.996, 1.0, hash12(p*uRes.x*0.8));
        float s2 = smoothstep(0.9982, 1.0, hash12(p*uRes.x*1.7 + 17.3));
        float s3 = smoothstep(0.999, 1.0, hash12(p*uRes.x*3.1 + 91.7));
        float stars = s1*0.6 + s2*1.0 + s3*1.6;

        // 星色微随机
        float k = hash12(p*1234.56);
        vec3 starCol = mix(vec3(0.90,0.95,1.0), vec3(1.0,0.92,0.82), k);

        vec3 col = nebCol + stars*starCol;
        return col * uBg;
      }

      // --------- 吸积盘辐射（含多普勒/增亮/红移近似） ---------
      vec3 diskEmission(vec3 hitPos, vec3 rayDir, float rMin){
        float rho = length(hitPos.xz);
        float rs = 2.0 * uMass;

        // 密度 & 亮度分布：偏向内侧，带一圈高亮
        float x = (rho - uDiskInner) / max(1e-3, (uDiskOuter - uDiskInner));
        float core = exp(-3.5*x);
        float band = exp(-pow((x-0.18)/0.09, 2.0)) * 0.9;
        float ring = exp(-pow((rho - (uDiskInner*1.15)) / (0.18*uDiskInner), 2.0));
        float dens = (0.25 + 1.2*core + band + 0.35*ring);

        // 湍动纹理（减少“塑料感”）
        float swirl = fbm(hitPos.xz*0.18 + vec2(uTime*0.03, -uTime*0.02));
        dens *= mix(0.6, 1.6, swirl);

        // 轨道速度（近似）：beta ~ sqrt(M/r)
        float beta = sqrt(uMass / max(rho, 1e-3));
        beta = clamp(beta, 0.0, 0.82);
        float gamma = 1.0 / sqrt(max(1e-4, 1.0 - beta*beta));

        // 速度方向：绕 y 轴切向
        vec3 vDir = normalize(vec3(-hitPos.z, 0.0, hitPos.x));
        float cosTheta = dot(vDir, -rayDir);
        float doppler = 1.0 / (gamma * (1.0 - beta * cosTheta));

        // 引力红移（Schwarzschild 近似）
        float g = sqrt(max(0.0, 1.0 - rs / max(rho, rs*1.001)));

        // 温度：T ~ r^{-3/4}
        float T = 8500.0 * pow(max(uDiskInner, 1e-3)/max(rho, 1e-3), 0.75);

        // 频移：T' ~ T * doppler * g
        float Tp = T * doppler * g;
        vec3  bb = blackbody(Tp);

        // 亮度：I ∝ dens * doppler^3 * g^4
        float I = dens * pow(doppler, 3.2) * pow(g, 3.8);

        // 让靠近“光子环”的路径更亮（贴近电影质感）
        float ps = 3.0*uMass;
        float ringGlow = exp(-pow((rMin - ps) / max(1e-3, (0.18*uMass)), 2.0));
        I *= 1.0 + uRingBoost * ringGlow;

        // 偏色：微暖 + 轻微青紫
        vec3 tintA = mix(vec3(1.05, 0.98, 0.92), vec3(0.92, 0.98, 1.08), uDiskTint);

        return bb * tintA * I * uDiskGlow;
      }

      // --------- 近似光线弯曲积分 ---------
      vec3 trace(vec3 ro, vec3 rd){
        float rs = 2.0 * uMass;
        float rH = rs * (1.0 + sqrt(max(0.0, 1.0 - uSpin*uSpin))); // Kerr 事件视界半径近似

        vec3 col = vec3(0.0);
        float trans = 1.0;
        float minR = 1e9;

        vec3 pos = ro;
        vec3 dir = rd;

        float steps = max(32.0, uSteps);
        float absorb = 0.10; // 盘的吸收（让盘有厚度与层次）

        for(int i=0;i<512;i++){
          if(float(i) >= steps) break;

          float r = length(pos);
          minR = min(minR, r);

          // 掉进黑洞
          if(r < rH * 1.001){
            trans = 0.0;
            break;
          }

          // 自适应步长：越近越细
          float t = clamp((r - rs) / (12.0*uMass), 0.0, 1.0);
          float ds = mix(uStepNear, uStepFar, t);

          vec3 pos2 = pos + dir * ds;

          // 检测穿过吸积盘：y=0，厚度 uDiskThick
          float y1 = pos.y;
          float y2 = pos2.y;
          float yMin = min(abs(y1), abs(y2));

          if(yMin < uDiskThick){
            float denom = (y1 - y2);
            float tt = (abs(denom) > 1e-6) ? (y1 / (y1 - y2)) : 0.5;
            tt = clamp(tt, 0.0, 1.0);
            vec3 hit = mix(pos, pos2, tt);

            float rho = length(hit.xz);
            if(rho > uDiskInner && rho < uDiskOuter){
              vec3 e = diskEmission(hit, dir, minR);

              // 薄片结构
              float thin = smoothstep(uDiskThick, 0.0, abs(hit.y));
              e *= (0.45 + 0.85*thin);

              // 前向散射感
              float fwd = pow(clamp(dot(-dir, vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5, 0.0, 1.0), 2.0);
              e *= (0.85 + 0.35*fwd);

              // 简单体渲染累积
              float a = 1.0 - exp(-absorb * (0.7 + 1.3*(uDiskOuter/rho)));
              a = clamp(a, 0.0, 0.95);
              col += trans * e * a;
              trans *= (1.0 - a);
              if(trans < 0.02) break;
            }
          }

          // 光线弯曲近似：保持 |dir|=1 的方向更新
          vec3 toC = pos;
          float rr = max(1e-4, dot(toC, toC));
          float invR = inversesqrt(rr);
          float invR3 = invR*invR*invR;

          vec3 perp = toC - dir * dot(toC, dir);

          vec3 ddir = -uBend * (2.0*uMass) * perp * invR3 * ds;

          // 帧拖曳：绕 y 轴扭转（近似 Kerr）
          vec3 spinAxis = vec3(0.0, 1.0, 0.0);
          vec3 twist = cross(spinAxis, perp);
          ddir += uSpin * 1.15 * (2.0*uMass) * twist * invR3 * ds;

          dir = normalize(dir + ddir);
          pos = pos2;

          if(r > 80.0*uMass) break; // 走太远就认为逃逸到背景
        }

        if(trans > 0.0){
          vec3 bg = sampleBackground(dir);
          col += trans * bg;
        }

        // 光子环增强：根据 minR 接近 photon sphere 的程度追加一圈
        float ps = 3.0*uMass;
        float ring = exp(-pow((minR - ps) / max(1e-3, (0.22*uMass)), 2.0));
        col += (0.18 + 0.55*uRingBoost) * ring * vec3(1.1, 0.95, 0.82);

        return col;
      }

      void main(){
        vec2 p = (vUv * 2.0 - 1.0);
        p.x *= uRes.x / uRes.y;

        float z = 1.0 / tan(radians(uFov) * 0.5);
        vec3 rd = normalize(uCamMat * vec3(p, -z));
        vec3 ro = uCamPos;

        vec3 col = trace(ro, rd);

        // 暗角
        float v = smoothstep(1.25, uVignette, dot(p, p));
        col *= (1.0 - 0.35*v);

        // 轻微胶片颗粒
        float g = hash12(vUv*uRes + fract(uTime)*123.4);
        col *= 1.0 + (g - 0.5) * 0.03;

        col = acesFilm(col);
        col = pow(col, vec3(1.0/2.2));

        gl_FragColor = vec4(col, 1.0);
      }
    `;

    // -----------------------------
    // Three.js 场景：全屏四边形 + 后期 Bloom
    // -----------------------------

    // importmap 不支持时的显式提示
    if (!('HTMLScriptElement' in window) || !('supports' in HTMLScriptElement) || !HTMLScriptElement.supports('importmap')) {
      warn('当前浏览器不支持 <code>importmap</code>，无法解析 three.js 的模块依赖。请使用新版 Chrome/Edge/Firefox。');
    }

    let renderer;
    try {
      renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    } catch (e) {
      warn('WebGL 初始化失败：' + String(e) + '<br/>请确认浏览器开启硬件加速，或换一台支持 WebGL 的设备。');
      throw e;
    }

    document.body.appendChild(renderer.domElement);

    // 限制 DPR，避免笔记本风扇起飞
    function getDpr(){
      return Math.min(window.devicePixelRatio || 1, 1.75);
    }

    const scene = new THREE.Scene();

    // “虚拟相机”：只用于控制与获取矩阵；画面由着色器做光追
    const camera = new THREE.PerspectiveCamera(50, 1, 0.01, 1000);
    camera.position.set(0.0, 2.2, 8.7);
    camera.lookAt(0, 0, 0);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 4.2;
    controls.maxDistance = 18.0;
    controls.maxPolarAngle = Math.PI * 0.60;
    controls.minPolarAngle = Math.PI * 0.08;

    // 全屏四边形
    const quadGeo = new THREE.PlaneGeometry(2, 2);

    const uniforms = {
      uRes:       { value: new THREE.Vector2(1, 1) },
      uTime:      { value: 0 },
      uCamPos:    { value: new THREE.Vector3() },
      uCamMat:    { value: new THREE.Matrix3() },
      uFov:       { value: 50 },

      uMass:      { value: 1.0 },
      uSpin:      { value: 0.94 },
      uDiskInner: { value: 3.2 },
      uDiskOuter: { value: 12.5 },
      uDiskThick: { value: 0.03 },
      uDiskGlow:  { value: 1.12 },
      uDiskTint:  { value: 0.18 },
      uBend:      { value: 1.05 },
      uSteps:     { value: 220 },
      uStepFar:   { value: 0.085 },
      uStepNear:  { value: 0.008 },
      uBg:        { value: 0.70 },
      uRingBoost: { value: 0.95 },
      uVignette:  { value: 1.03 }
    };

    const mat = new THREE.ShaderMaterial({
      uniforms,
      vertexShader: VERT,
      fragmentShader: FRAG,
      depthTest: false,
      depthWrite: false
    });

    const quad = new THREE.Mesh(quadGeo, mat);
    scene.add(quad);

    // 后期 Bloom
    const composer = new EffectComposer(renderer);
    const ortho = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    const renderPass = new RenderPass(scene, ortho);
    composer.addPass(renderPass);

    const bloomPass = new UnrealBloomPass(new THREE.Vector2(1, 1), 0.9, 0.55, 0.22);
    composer.addPass(bloomPass);

    // GUI
    const gui = new GUI({ width: 340, title: 'Gargantua 调参' });
    const params = {
      preset: () => {
        camera.position.set(0.0, 2.2, 8.7);
        controls.target.set(0, 0, 0);
        controls.update();
        uniforms.uMass.value = 1.0;
        uniforms.uSpin.value = 0.94;
        uniforms.uDiskInner.value = 3.2;
        uniforms.uDiskOuter.value = 12.5;
        uniforms.uDiskThick.value = 0.03;
        uniforms.uDiskGlow.value = 1.12;
        uniforms.uDiskTint.value = 0.18;
        uniforms.uBend.value = 1.05;
        uniforms.uSteps.value = 220;
        uniforms.uStepFar.value = 0.085;
        uniforms.uStepNear.value = 0.008;
        uniforms.uBg.value = 0.70;
        uniforms.uRingBoost.value = 0.95;
        uniforms.uVignette.value = 1.03;
        bloomPass.strength = 0.90;
        bloomPass.radius = 0.55;
        bloomPass.threshold = 0.22;
      },
      bloom: true,
      screenshot: () => {
        const a = document.createElement('a');
        a.download = 'gargantua.png';
        a.href = renderer.domElement.toDataURL('image/png');
        a.click();
      },
      runTests: () => {
        try {
          const gl = renderer.getContext();
          selfTests({ renderer, gl });
          alert('自检已输出到控制台（F12）。');
        } catch (e) {
          console.error(e);
          alert('自检失败，详见控制台。');
        }
      }
    };

    gui.add(params, 'preset').name('电影预设');
    gui.add(params, 'runTests').name('运行自检');

    const fPhys = gui.addFolder('黑洞与盘');
    fPhys.add(uniforms.uMass, 'value', 0.6, 1.8, 0.01).name('质量 uMass');
    fPhys.add(uniforms.uSpin, 'value', 0.0, 0.999, 0.001).name('自旋 uSpin');
    fPhys.add(uniforms.uDiskInner, 'value', 2.2, 6.0, 0.01).name('盘内半径');
    fPhys.add(uniforms.uDiskOuter, 'value', 8.0, 22.0, 0.01).name('盘外半径');
    fPhys.add(uniforms.uDiskThick, 'value', 0.005, 0.12, 0.001).name('盘厚度');
    fPhys.add(uniforms.uDiskGlow, 'value', 0.2, 3.0, 0.01).name('盘亮度');
    fPhys.add(uniforms.uDiskTint, 'value', 0.0, 1.0, 0.01).name('盘偏色');
    fPhys.add(uniforms.uRingBoost, 'value', 0.0, 2.5, 0.01).name('光子环增强');

    const fRay = gui.addFolder('光线积分');
    fRay.add(uniforms.uBend, 'value', 0.6, 1.8, 0.01).name('弯曲强度');
    fRay.add(uniforms.uSteps, 'value', 80, 420, 1).name('步数');
    fRay.add(uniforms.uStepFar, 'value', 0.03, 0.16, 0.001).name('远步长');
    fRay.add(uniforms.uStepNear, 'value', 0.002, 0.03, 0.001).name('近步长');

    const fLook = gui.addFolder('观感');
    fLook.add(uniforms.uBg, 'value', 0.0, 1.4, 0.01).name('背景强度');
    fLook.add(uniforms.uVignette, 'value', 0.85, 1.35, 0.01).name('暗角');

    const fBloom = gui.addFolder('Bloom');
    fBloom.add(params, 'bloom').name('开启 Bloom').onChange(v => {
      bloomPass.enabled = !!v;
    });
    fBloom.add(bloomPass, 'strength', 0.0, 2.5, 0.01).name('强度');
    fBloom.add(bloomPass, 'radius', 0.0, 1.2, 0.01).name('半径');
    fBloom.add(bloomPass, 'threshold', 0.0, 1.0, 0.01).name('阈值');

    gui.add(params, 'screenshot').name('截图');

    // 画面尺寸
    function resize(){
      const w = window.innerWidth;
      const h = window.innerHeight;
      const dpr = getDpr();
      renderer.setPixelRatio(dpr);
      renderer.setSize(w, h);
      composer.setPixelRatio(dpr);
      composer.setSize(w, h);
      uniforms.uRes.value.set(w * dpr, h * dpr);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      uniforms.uFov.value = camera.fov;
      bloomPass.setSize(w * dpr, h * dpr);
    }
    window.addEventListener('resize', resize);
    resize();

    // 相机矩阵传给 shader：用相机的世界矩阵提取 basis
    const _m3 = new THREE.Matrix3();
    function updateCamUniforms(){
      uniforms.uCamPos.value.copy(camera.position);
      const e = camera.matrixWorld.elements;
      const right = new THREE.Vector3(e[0], e[1], e[2]);
      const up    = new THREE.Vector3(e[4], e[5], e[6]);
      const fwd   = new THREE.Vector3(-e[8], -e[9], -e[10]);
      _m3.set(
        right.x, up.x, fwd.x,
        right.y, up.y, fwd.y,
        right.z, up.z, fwd.z
      );
      uniforms.uCamMat.value.copy(_m3);
      uniforms.uFov.value = camera.fov;
    }

    // 启动前做一次自检（也方便你在控制台看到基础信息）
    try {
      const gl = renderer.getContext();
      selfTests({ renderer, gl });
    } catch (e) {
      console.error(e);
    }

    // 动画
    const clock = new THREE.Clock();
    function tick(){
      const t = clock.getElapsedTime();
      uniforms.uTime.value = t;
      controls.update();
      updateCamUniforms();
      composer.render();
      requestAnimationFrame(tick);
    }
    tick();

    fPhys.open();
    fBloom.open();

  </script>
</body>
</html>
